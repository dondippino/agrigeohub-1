import { first } from 'rxjs/operator/first';
import { switchMap } from 'rxjs/operator/switchMap';
import { map } from 'rxjs/operator/map';
import { _catch } from 'rxjs/operator/catch';
import { _throw } from 'rxjs/observable/throw';
import { InjectionToken, Injectable, Inject, Injector, NgModule } from '@angular/core';
import { Router } from '@angular/router';
import { HttpClient, HTTP_INTERCEPTORS } from '@angular/common/http';
import { Subject } from 'rxjs/Subject';

var AuthService = /** @class */ (function () {
    function AuthService() {
    }
    return AuthService;
}());
function first$1(obs) {
    return first.call(obs);
}
function switchMap$1(obs, project) {
    return switchMap.call(obs, project);
}
function map$1(obs, project) {
    return map.call(obs, project);
}
function _catch$1(obs, selector) {
    return _catch.call(obs, selector);
}
var AUTH_SERVICE = new InjectionToken('AUTH_SERVICE');
var PUBLIC_FALLBACK_PAGE_URI = new InjectionToken('PUBLIC_FALLBACK_PAGE_URI');
var PROTECTED_FALLBACK_PAGE_URI = new InjectionToken('PROTECTED_FALLBACK_PAGE_URI');
var PublicGuard = /** @class */ (function () {
    function PublicGuard(authService, protectedFallbackPageUri, router) {
        this.authService = authService;
        this.protectedFallbackPageUri = protectedFallbackPageUri;
        this.router = router;
    }
    PublicGuard.prototype.canActivate = function (_route, state) {
        var _this = this;
        return map$1(this.authService.isAuthorized(), function (isAuthorized) {
            if (isAuthorized && !_this.isProtectedPage(state)) {
                _this.navigate(_this.protectedFallbackPageUri);
                return false;
            }
            return true;
        });
    };
    PublicGuard.prototype.canActivateChild = function (route, state) {
        return this.canActivate(route, state);
    };
    PublicGuard.prototype.isProtectedPage = function (state) {
        return state.url === this.protectedFallbackPageUri;
    };
    PublicGuard.prototype.navigate = function (url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    };
    return PublicGuard;
}());
PublicGuard.decorators = [
    { type: Injectable },
];
PublicGuard.ctorParameters = function () { return [
    { type: AuthService, decorators: [{ type: Inject, args: [AUTH_SERVICE,] },] },
    { type: undefined, decorators: [{ type: Inject, args: [PROTECTED_FALLBACK_PAGE_URI,] },] },
    { type: Router, },
]; };
var ProtectedGuard = /** @class */ (function () {
    function ProtectedGuard(authService, publicFallbackPageUri, router) {
        this.authService = authService;
        this.publicFallbackPageUri = publicFallbackPageUri;
        this.router = router;
    }
    ProtectedGuard.prototype.canActivate = function (_route, state) {
        var _this = this;
        return map$1(this.authService.isAuthorized(), function (isAuthorized) {
            if (!isAuthorized && !_this.isPublicPage(state)) {
                _this.navigate(_this.publicFallbackPageUri);
                return false;
            }
            return true;
        });
    };
    ProtectedGuard.prototype.canActivateChild = function (route, state) {
        return this.canActivate(route, state);
    };
    ProtectedGuard.prototype.isPublicPage = function (state) {
        return state.url === this.publicFallbackPageUri;
    };
    ProtectedGuard.prototype.navigate = function (url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    };
    return ProtectedGuard;
}());
ProtectedGuard.decorators = [
    { type: Injectable },
];
ProtectedGuard.ctorParameters = function () { return [
    { type: AuthService, decorators: [{ type: Inject, args: [AUTH_SERVICE,] },] },
    { type: undefined, decorators: [{ type: Inject, args: [PUBLIC_FALLBACK_PAGE_URI,] },] },
    { type: Router, },
]; };
var AuthInterceptor = /** @class */ (function () {
    function AuthInterceptor(injector) {
        this.injector = injector;
        this.refreshInProgress = false;
        this.refreshSubject = new Subject();
    }
    AuthInterceptor.prototype.intercept = function (req, delegate) {
        var authService = this.injector.get(AUTH_SERVICE);
        if (authService.verifyTokenRequest(req.url)) {
            return delegate.handle(req);
        }
        return this.processIntercept(req, delegate);
    };
    AuthInterceptor.prototype.processIntercept = function (original, delegate) {
        var _this = this;
        var clone = original.clone();
        return _catch$1(switchMap$1(this.request(clone), function (req) { return delegate.handle(req); }), function (res) { return _this.responseError(clone, res); });
    };
    AuthInterceptor.prototype.request = function (req) {
        if (this.refreshInProgress) {
            return this.delayRequest(req);
        }
        return this.addToken(req);
    };
    AuthInterceptor.prototype.responseError = function (req, res) {
        var _this = this;
        var authService = this.injector.get(AUTH_SERVICE);
        var refreshShouldHappen = authService.refreshShouldHappen(res);
        if (refreshShouldHappen && !this.refreshInProgress) {
            this.refreshInProgress = true;
            authService
                .refreshToken()
                .subscribe(function () {
                _this.refreshInProgress = false;
                _this.refreshSubject.next(true);
            }, function () {
                _this.refreshInProgress = false;
                _this.refreshSubject.next(false);
            });
        }
        if (refreshShouldHappen && this.refreshInProgress) {
            return this.retryRequest(req, res);
        }
        return _throw(res);
    };
    AuthInterceptor.prototype.addToken = function (req) {
        var authService = this.injector.get(AUTH_SERVICE);
        return first$1(map$1(authService.getAccessToken(), function (token) {
            if (token) {
                var setHeaders = void 0;
                if (typeof authService.getHeaders === 'function') {
                    setHeaders = authService.getHeaders(token);
                }
                else {
                    setHeaders = { Authorization: "Bearer " + token };
                }
                return req.clone({ setHeaders: setHeaders });
            }
            return req;
        }));
    };
    AuthInterceptor.prototype.delayRequest = function (req) {
        var _this = this;
        return switchMap$1(first$1(this.refreshSubject), function (status) { return status ? _this.addToken(req) : _throw(req); });
    };
    AuthInterceptor.prototype.retryRequest = function (req, res) {
        var http = this.injector.get(HttpClient);
        return switchMap$1(first$1(this.refreshSubject), function (status) { return status ? http.request(req) : _throw(res || req); });
    };
    return AuthInterceptor;
}());
AuthInterceptor.decorators = [
    { type: Injectable },
];
AuthInterceptor.ctorParameters = function () { return [
    { type: Injector, },
]; };
var AuthModule = /** @class */ (function () {
    function AuthModule() {
    }
    return AuthModule;
}());
AuthModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    PublicGuard,
                    ProtectedGuard,
                    AuthInterceptor,
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: AuthInterceptor,
                        multi: true,
                    }
                ]
            },] },
];
AuthModule.ctorParameters = function () { return []; };

export { AuthService, PublicGuard, ProtectedGuard, AUTH_SERVICE, PUBLIC_FALLBACK_PAGE_URI, PROTECTED_FALLBACK_PAGE_URI, AuthModule, AuthInterceptor as Éµa };
//# sourceMappingURL=ngx-auth.js.map
