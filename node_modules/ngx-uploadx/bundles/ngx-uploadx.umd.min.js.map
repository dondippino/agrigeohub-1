{
  "version": 3,
  "file": "ngx-uploadx.umd.min.js",
  "sources": [
    "ng://ngx-uploadx/out/interfaces.ts",
    "ng://ngx-uploadx/out/backoffRetry.ts",
    "ng://ngx-uploadx/out/xhrfactory.ts",
    "ng://ngx-uploadx/out/uploader.ts",
    "ng://ngx-uploadx/out/uploadx.service.ts",
    "ng://ngx-uploadx/out/uploadx.directive.ts",
    "ng://ngx-uploadx/out/uploadx.module.ts"
  ],
  "sourcesContent": [
    "export type UploadStatus =\n  | 'added'\n  | 'queue'\n  | 'uploading'\n  | 'complete'\n  | 'error'\n  | 'cancelled'\n  | 'paused';\n\nexport type UploadAction =\n  | 'create'\n  | 'uploadAll'\n  | 'upload'\n  | 'cancel'\n  | 'cancelAll'\n  | 'pauseAll'\n  | 'pause';\nexport interface UploadxControlEvent {\n  action: UploadAction;\n  /**\n   * override global options\n   */\n  itemOptions?: UploadItem;\n  /** Upload unique identifier */\n  uploadId?: string;\n}\n/**\n *  Read only upload stream events\n */\nexport interface UploadState {\n  file: File;\n  name: string;\n  progress: number;\n  remaining: number;\n  response: any;\n  size: number;\n  speed: number;\n  status: UploadStatus;\n  uploadId: string;\n  URI: string;\n}\n\nexport interface UploadItem {\n  /**\n   * Upload API initial method\n   * @default 'POST'\n   */\n  method?: string;\n  readonly uploadId?: string;\n  /**\n   * Upload API URL\n   * @default '/upload/'\n   */\n  url?: string;\n  /**\n   * Custom headers\n   */\n  headers?: { [key: string]: string } | Function;\n  /**\n   * Upload meta\n   * @default\n   * { name: File.Filename, mimeType: File.type }\n   */\n  metadata?: any;\n}\n/**\n * Global Options\n */\nexport class UploadxOptions implements UploadItem {\n  /**\n   *  Set \"accept\" attribute\n   * @example\n   * allowedTypes: 'image/*, video/*'\n   */\n  allowedTypes?: string;\n  /**\n   * Auto upload with global options\n   * @default true\n   */\n  autoUpload?: boolean;\n  /**\n   * If set use chunks for upload\n   * @default 0\n   */\n  chunkSize?: number;\n  /**\n   * Uploads in parallel\n   * @default 2\n   */\n  concurrency?: number;\n  /**\n   * Custom headers\n   */\n  headers?: { [key: string]: string } | Function;\n  /**\n   * Upload API initial method\n   * @default 'POST'\n   */\n  method?: string;\n  /**\n   * Authorization Bearer token\n   */\n  token?: string;\n  /**\n   * Upload API URL\n   * @default '/upload/'\n   */\n  url?: string;\n  /**\n   * Use withCredentials xhr option?\n   * @default false\n   */\n  withCredentials?: boolean;\n}\n/**\n * @inner\n */\nexport interface UploaderOptions extends UploadItem {\n  token?: string;\n  chunkSize?: number;\n  withCredentials?: boolean;\n  readonly subj?: any;\n  readonly nextFile?: () => void;\n}\n",
    "/**\n *  Exponential Backoff Retries\n */\nexport class BackoffRetry {\n  private delay: number;\n  /**\n   *\n   * Creates an instance of BackoffRetry.\n   * @default\n   * minInterval = 1000 ms\n   * maxInterval = minInterval * 120 (2 min)\n   * k = 2\n   */\n  constructor(\n    private minInterval = 1000,\n    private maxInterval = minInterval * 120,\n    private k = 2\n  ) {\n    this.delay = this.minInterval;\n  }\n  // TODO implement the \"Retry-After\"\n  /**\n   * Delay Retry\n   */\n  wait(): Promise<{}> {\n    return new Promise(resolve => {\n      setTimeout(resolve, this.delay + Math.floor(Math.random() * this.minInterval));\n      this.delay = Math.min(this.delay * this.k, this.maxInterval);\n    });\n  }\n  /**\n   * Reset Retry Interval\n   */\n  reset(): void {\n    this.delay = this.minInterval;\n  }\n}\n",
    "export let XHRFactory = (() => {\n  let stack = Array(1).fill(createXHR());\n\n  function createXHR() {\n    return new XMLHttpRequest();\n  }\n\n  return {\n    release: (xhr) => {\n      xhr.onreadystatechange = null;\n      xhr.onerror = null;\n      xhr.onload = null;\n      xhr.upload.onprogress = null;\n      stack.push(xhr);\n    },\n    getInstance() {\n      if (!stack.length) {\n        return createXHR();\n      } else {\n        return stack.pop();\n      }\n    },\n    get size() {\n      return stack.length;\n    },\n    set size(s) {\n      stack = Array(s).fill(createXHR());\n    }\n  };\n})();\n",
    "import { Subject } from 'rxjs/Subject';\n\nimport { BackoffRetry } from './backoffRetry';\nimport { XHRFactory } from './xhrfactory';\nimport {\n  UploadStatus,\n  UploadItem,\n  UploaderOptions,\n  UploadState\n} from './interfaces';\n\nconst noop = () => {};\n/**\n * Implements XHR/CORS Resumable Upload\n * @see\n * https://developers.google.com/drive/v3/web/resumable-upload\n * https://developer.vimeo.com/api/upload/videos#resumable-upload\n */\nexport class Uploader implements UploaderOptions {\n  headers: any;\n  metadata: any;\n  method: string;\n  mimeType: string;\n  name: string;\n  progress: number;\n  remaining: number;\n  response: any;\n  size: number;\n  speed: number;\n  uploadId: string;\n  url: any;\n  private startTime: number;\n  private _status: UploadStatus;\n  private retry: BackoffRetry;\n  private abort;\n  /**\n   * Creates an instance of Uploader.\n   */\n  constructor(private file: File, private options: UploaderOptions) {\n    this.uploadId = Math.random()\n      .toString(36)\n      .substring(2, 15);\n    this.name = file.name;\n    this.size = file.size;\n    this.mimeType = file.type || 'application/octet-stream';\n    this.status = 'added';\n    this.retry = new BackoffRetry();\n  }\n  /**\n   * Set individual file options and add to queue\n   */\n  configure(item: UploadItem = {}) {\n    if (this.status === 'added') {\n      const { metadata, headers } = item;\n      this.metadata = {\n        name: this.name,\n        mimeType: this.mimeType,\n        ...this.options.metadata,\n        ...metadata\n      };\n      this.headers =\n        this.options.headers instanceof Function\n          ? this.options.headers(this.file)\n          : { ...this.options.headers, ...headers };\n      this.url = this.options.url;\n      this.method = this.options.method;\n    }\n    this.status = 'queue';\n  }\n\n  set status(s: UploadStatus) {\n    this._status = s;\n    this.notifyState();\n    if (s === 'cancelled' || s === 'paused') {\n      this.abort();\n    }\n  }\n  get status() {\n    return this._status;\n  }\n  /**\n   * Emit current state\n   */\n  private notifyState() {\n    const state: UploadState = {\n      file: this.file,\n      name: this.name,\n      progress: this.progress,\n      remaining: this.remaining,\n      response: this.response,\n      size: this.size,\n      speed: this.speed,\n      status: this._status,\n      uploadId: this.uploadId,\n      URI: this.url\n    };\n    // tick for control events detect\n    setTimeout(() => {\n      this.options.subj.next(state);\n    });\n  }\n\n  private setHeaders(xhr: XMLHttpRequest) {\n    if (this.headers) {\n      Object.keys(this.headers).forEach(key =>\n        xhr.setRequestHeader(key, this.headers[key])\n      );\n    }\n  }\n\n  /**\n   * Initiate upload\n   */\n  upload() {\n    if (this.status === 'added') {\n      this.configure();\n    }\n    this.status = 'uploading';\n    if (this.progress > 0) {\n      return this.resume();\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'json';\n    xhr.open(this.method, this.options.url, true);\n    if (!!this.options.withCredentials) {\n      xhr.withCredentials = true;\n    }\n    this.setHeaders(xhr);\n    this.options.token\n      ? xhr.setRequestHeader('Authorization', 'Bearer ' + this.options.token)\n      : noop();\n    xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');\n    xhr.setRequestHeader('X-Upload-Content-Length', this.size.toString());\n    xhr.setRequestHeader('X-Upload-Content-Type', this.mimeType);\n    xhr.onload = () => {\n      if (xhr.status < 400 && xhr.status > 199) {\n        // get secure upload link\n        this.url = xhr.getResponseHeader('Location');\n        this.startTime = this.startTime || new Date().getTime();\n        this.sendFile();\n      } else {\n        this.response = xhr.response;\n        this.status = 'error';\n      }\n    };\n    xhr.send(JSON.stringify(this.metadata));\n  }\n  /**\n   * Request upload state after 5xx errors or network failures\n   */\n  private resume(): void {\n    const xhr: XMLHttpRequest = XHRFactory.getInstance();\n    if (xhr.responseType !== 'json') {\n      xhr.responseType = 'json';\n    }\n    xhr.open('PUT', this.url, true);\n    if (!!this.options.withCredentials) {\n      xhr.withCredentials = true;\n    }\n    xhr.setRequestHeader('Content-Range', `bytes */${this.size}`);\n    xhr.setRequestHeader('Content-Type', this.mimeType);\n    this.setHeaders(xhr);\n    const onDataSendError = () => {\n      // 5xx errors or network failures\n      if (xhr.status > 499 || !xhr.status) {\n        XHRFactory.release(xhr);\n        this.retry.wait().then(() => this.resume());\n      } else {\n        // 4xx errors\n        this.response = xhr.response || {\n          error: {\n            code: xhr.status,\n            message: xhr.statusText\n          }\n        };\n        this.status = 'error';\n        XHRFactory.release(xhr);\n        this.options.nextFile();\n      }\n    };\n    const onDataSendSuccess = () => {\n      if (xhr.status === 200 || xhr.status === 201) {\n        this.progress = 100;\n        this.response = xhr.response;\n        this.status = 'complete';\n        XHRFactory.release(xhr);\n        this.options.nextFile();\n      } else if (xhr.status && xhr.status < 400) {\n        const range = +xhr.getResponseHeader('Range').split('-')[1] + 1;\n        this.retry.reset();\n        XHRFactory.release(xhr);\n        this.abort = this.sendFile(range);\n      } else {\n        onDataSendError();\n      }\n    };\n    xhr.onerror = onDataSendError;\n    xhr.onload = onDataSendSuccess;\n    xhr.send();\n  }\n  /**\n   * Content upload\n   */\n  private sendFile(start: number = 0): () => void {\n    if (this.status === 'cancelled' || this.status === 'paused') {\n      return;\n    }\n    let end: number = this.options.chunkSize\n      ? start + this.options.chunkSize\n      : this.size;\n    end = end > this.size ? this.size : end;\n    const chunk: Blob = this.file.slice(start, end);\n    const xhr: XMLHttpRequest = XHRFactory.getInstance();\n    if (xhr.responseType !== 'json') {\n      xhr.responseType = 'json';\n    }\n\n    xhr.open('PUT', this.url, true);\n    if (!!this.options.withCredentials) {\n      xhr.withCredentials = true;\n    }\n    xhr.setRequestHeader(\n      'Content-Range',\n      `bytes ${start}-${end - 1}/${this.size}`\n    );\n    xhr.setRequestHeader('Content-Type', this.mimeType);\n    this.setHeaders(xhr);\n    const updateProgress = (pEvent: ProgressEvent) => {\n      const uploaded = pEvent.lengthComputable\n        ? start + (end - start) * (pEvent.loaded / pEvent.total)\n        : start;\n      this.progress = +(uploaded / this.size * 100).toFixed(2);\n      const now = new Date().getTime();\n      this.speed = Math.round(uploaded / (now - this.startTime) * 1000);\n      this.remaining = Math.ceil((this.size - uploaded) / this.speed);\n      this.notifyState();\n    };\n    const onDataSendError = () => {\n      // 5xx errors or network failures\n      if (xhr.status > 499 || !xhr.status) {\n        XHRFactory.release(xhr);\n        this.retry.wait().then(() => this.resume());\n      } else {\n        // 4xx errors\n        this.response = xhr.response || {\n          error: {\n            code: +xhr.status,\n            message: xhr.statusText\n          }\n        };\n        this.status = 'error';\n        XHRFactory.release(xhr);\n        this.options.nextFile();\n      }\n    };\n    const onDataSendSuccess = () => {\n      if (xhr.status === 200 || xhr.status === 201) {\n        this.progress = 100;\n        this.response = xhr.response;\n        this.status = 'complete';\n        XHRFactory.release(xhr);\n        this.options.nextFile();\n      } else if (xhr.status && xhr.status < 400) {\n        const range = +xhr.getResponseHeader('Range').split('-')[1] + 1;\n        this.retry.reset();\n        XHRFactory.release(xhr);\n        // send next chunk\n        this.abort = this.sendFile(range);\n      } else {\n        onDataSendError();\n      }\n    };\n    xhr.onerror = onDataSendError;\n    xhr.onload = onDataSendSuccess;\n    xhr.upload.onprogress = updateProgress;\n    xhr.send(chunk);\n    return () => {\n      xhr.abort();\n    };\n  }\n}\n",
    "import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\n\nimport {\n  UploadxOptions,\n  UploadState,\n  UploadxControlEvent,\n  UploaderOptions\n} from './interfaces';\nimport { Uploader } from './uploader';\n/**\n *\n */\n@Injectable()\nexport class UploadxService {\n  subj: Subject<UploadState> = new Subject();\n  private queue: Uploader[] = [];\n  private concurrency = 2;\n  private autoUpload = true;\n  private options: UploadxOptions;\n\n  get uploaderOptions(): UploaderOptions {\n    return {\n      method: this.options.method || 'POST',\n      url: this.options.url || '/upload/',\n      headers: this.options.headers,\n      token: this.options.token,\n      chunkSize: this.options.chunkSize || 0,\n      withCredentials: this.options.withCredentials || false,\n      subj: this.subj,\n      nextFile: () => this.processQueue()\n    };\n  }\n  /**\n   * Set global module options\n   */\n  init(options: UploadxOptions): Observable<UploadState> {\n    this.options = options;\n    this.concurrency = options.concurrency || this.concurrency;\n    this.autoUpload = options.autoUpload || false;\n    return this.subj.asObservable();\n  }\n  /**\n   *\n   * Create Uploader and add to the queue\n   */\n  handleFileList(fileList: FileList) {\n    for (let i = 0; i < fileList.length; i++) {\n      const uploader: Uploader = new Uploader(\n        fileList.item(i),\n        this.uploaderOptions\n      );\n      this.queue.push(uploader);\n    }\n    if (this.autoUpload) {\n      this.queue.forEach(upload => {\n        upload.configure();\n      });\n      this.processQueue();\n    }\n  }\n  /**\n   * Control upload status\n   * @example\n   * this.uploadService.control({ action: 'pauseAll' });\n   *\n   */\n  control(event: UploadxControlEvent) {\n    switch (event.action) {\n      case 'cancelAll':\n        this.queue\n          .filter(f => f.status !== 'complete')\n          .map(f => (f.status = 'cancelled'));\n        break;\n      case 'pauseAll':\n        this.queue\n          .filter(f => f.status !== 'complete')\n          .map(f => (f.status = 'paused'));\n        break;\n      case 'uploadAll':\n        this.queue\n          .filter(f => f.status !== 'complete' && f.status !== 'uploading')\n          .map(f => (f.status = 'queue'));\n        this.processQueue();\n        break;\n      case 'upload':\n        const uploadId = event.uploadId || event.itemOptions.uploadId;\n        const target = this.queue.find(f => f.uploadId === uploadId);\n        target.configure(event.itemOptions);\n        this.processQueue();\n        break;\n      case 'cancel':\n        this.queue.find(f => f.uploadId === event.uploadId).status =\n          'cancelled';\n        break;\n      case 'pause':\n        this.queue.find(f => f.uploadId === event.uploadId).status = 'paused';\n        break;\n      default:\n        break;\n    }\n  }\n  /**\n   * Queue management\n   */\n  private processQueue() {\n    const running = this.queue.filter(\n      (uploader: Uploader) => uploader.status === 'uploading'\n    );\n\n    const completed = this.queue.findIndex(\n      (uploader: Uploader) => uploader.status === 'complete'\n    );\n    if (completed !== -1) {\n      this.queue.splice(completed, 1);\n    }\n    this.queue\n      .filter((uploader: Uploader) => uploader.status === 'queue')\n      .slice(0, this.concurrency - running.length)\n      .forEach((uploader: Uploader) => {\n        uploader.upload();\n      });\n  }\n}\n",
    "import {\n  Directive,\n  ElementRef,\n  Renderer2,\n  OnInit,\n  OnDestroy,\n  Input,\n  Output,\n  EventEmitter\n} from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { UploadxOptions, UploadState, UploadxControlEvent } from './interfaces';\nimport { UploadxService } from './uploadx.service';\n\n@Directive({\n  // tslint:disable-next-line:directive-selector\n  selector: '[uploadx]'\n})\nexport class UploadxDirective implements OnInit, OnDestroy {\n  listenerFn: () => void;\n  @Output() uploadxState = new EventEmitter();\n  @Input('uploadx') uploadx: UploadxOptions;\n  @Input('uploadxAction')\n  set uploadxAction(ctrlEvent: UploadxControlEvent) {\n    if (ctrlEvent && this.uploadService) {\n      this.uploadService.control(ctrlEvent);\n    }\n  }\n  constructor(\n    private elementRef: ElementRef,\n    private renderer: Renderer2,\n    private uploadService: UploadxService\n  ) { }\n\n  ngOnInit() {\n    if (this.uploadx) {\n      if (this.uploadx.allowedTypes) {\n        this.renderer.setAttribute(\n          this.elementRef.nativeElement,\n          'accept',\n          this.uploadx.allowedTypes\n        );\n      }\n      this.uploadService.init(this.uploadx);\n    }\n    this.uploadxState.emit(\n      <Observable<UploadState>>this.uploadService.subj.asObservable()\n    );\n    this.listenerFn = this.renderer.listen(\n      this.elementRef.nativeElement, 'change', this.fileListener\n    );\n  }\n\n  ngOnDestroy() {\n    if (this.listenerFn) {\n      this.listenerFn();\n    }\n  }\n\n  fileListener = () => {\n    if (this.elementRef.nativeElement.files) {\n      this.uploadService.handleFileList(this.elementRef.nativeElement.files);\n    }\n  }\n}\n",
    "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { UploadxDirective } from './uploadx.directive';\nimport { UploadxService } from './uploadx.service';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [UploadxDirective],\n  exports: [UploadxDirective],\n  providers: [UploadxService]\n})\nexport class UploadxModule { }\n"
  ],
  "names": [
    "UploadxOptions",
    "BackoffRetry",
    "minInterval",
    "maxInterval",
    "k",
    "this",
    "delay",
    "prototype",
    "wait",
    "_this",
    "Promise",
    "resolve",
    "setTimeout",
    "Math",
    "floor",
    "random",
    "min",
    "reset",
    "XHRFactory",
    "stack",
    "Array",
    "fill",
    "createXHR",
    "XMLHttpRequest",
    "release",
    "xhr",
    "onreadystatechange",
    "onerror",
    "onload",
    "upload",
    "onprogress",
    "push",
    "getInstance",
    "length",
    "pop",
    "size",
    "s",
    "Uploader",
    "file",
    "options",
    "uploadId",
    "toString",
    "substring",
    "name",
    "mimeType",
    "type",
    "status",
    "retry",
    "configure",
    "item",
    "metadata",
    "headers",
    "Object",
    "assign",
    "Function",
    "url",
    "method",
    "defineProperty",
    "get",
    "_status",
    "set",
    "notifyState",
    "abort",
    "state",
    "progress",
    "remaining",
    "response",
    "speed",
    "URI",
    "subj",
    "next",
    "setHeaders",
    "keys",
    "forEach",
    "key",
    "setRequestHeader",
    "resume",
    "responseType",
    "open",
    "withCredentials",
    "token",
    "getResponseHeader",
    "startTime",
    "Date",
    "getTime",
    "sendFile",
    "send",
    "JSON",
    "stringify",
    "onDataSendError",
    "then",
    "error",
    "code",
    "message",
    "statusText",
    "nextFile",
    "range",
    "split",
    "start",
    "end",
    "chunkSize",
    "chunk",
    "slice",
    "pEvent",
    "uploaded",
    "lengthComputable",
    "loaded",
    "total",
    "toFixed",
    "now",
    "round",
    "ceil",
    "UploadxService",
    "Subject",
    "queue",
    "concurrency",
    "autoUpload",
    "processQueue",
    "init",
    "asObservable",
    "handleFileList",
    "fileList",
    "i",
    "uploader",
    "uploaderOptions",
    "control",
    "event",
    "action",
    "filter",
    "f",
    "map",
    "uploadId_1",
    "itemOptions",
    "find",
    "running",
    "completed",
    "findIndex",
    "splice",
    "Injectable",
    "UploadxDirective",
    "elementRef",
    "renderer",
    "uploadService",
    "uploadxState",
    "EventEmitter",
    "fileListener",
    "nativeElement",
    "files",
    "ctrlEvent",
    "ngOnInit",
    "uploadx",
    "allowedTypes",
    "setAttribute",
    "emit",
    "listenerFn",
    "listen",
    "ngOnDestroy",
    "Directive",
    "args",
    "selector",
    "ElementRef",
    "Renderer2",
    "Output",
    "Input",
    "uploadxAction",
    "UploadxModule",
    "NgModule",
    "imports",
    "CommonModule",
    "declarations",
    "exports",
    "providers"
  ],
  "mappings": "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"
}
